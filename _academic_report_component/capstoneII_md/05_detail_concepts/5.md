# 5. Detail Concepts

This chapter presents the detailed design concepts behind Modula, including the choice of technology and the system architecture. Compared to Capstone I, Capstone II places more emphasis on production-oriented concerns such as offline-first synchronization, reliability under retries, and the practical deployment model for the `/v0` system.

Some infrastructure choices are already decided for Capstone II (backend hosting, database, and object storage), while other components remain to be selected (frontend hosting, OTP provider, CDN strategy). Where decisions are not yet final, this report explicitly flags them using `TODO_CAPSTONE2(...)`.

---

## 5.1 Choice of Technology

### 5.1.1 Language and Framework

Modula uses a modern, cross-platform technology stack designed to support maintainability and gradual evolution from an academic prototype into a production-oriented system.

For the frontend, Modula uses **Flutter** with **Dart**, supported by **Riverpod** for state management and dependency injection. Flutter was selected to support a single codebase with a consistent experience across device sizes. In Capstone II, Modula prioritizes responsive usability for both **small screens (smartphones)** and **wide screens (tablets and desktops)**.

For the backend, Modula is implemented using **TypeScript** on a Node.js runtime. TypeScript was selected to provide static typing and safer refactoring in a system where multiple modules exchange structured data (sales, inventory, policy enforcement, synchronization, and auditability).

### 5.1.2 Databases

Modula uses two complementary persistence layers:

- **Server-side authoritative database**: PostgreSQL is used as the system-of-record for transactional and operational data (sales, orders, inventory journal, cash sessions, attendance, policies, audit logs). Strong ACID guarantees and relational integrity are important for POS correctness and auditability.
- **Client-side local database**: IndexedDB is used inside the web client for offline-first behavior, including:
  - local cache of reference data (e.g., menu and policy),
  - durable queue of offline operations,
  - device checkpoints/cursors for incremental hydration.

The authoritative source of truth remains the server-side database. The client-side database is used for resilience and performance, and is reconciled through synchronization mechanisms (push replay + pull hydration).

### 5.1.3 Tools

The project uses a set of tools to support development, documentation, testing, and collaboration:

- **GitHub** for version control and collaboration.
- **Jira** for task tracking and progress monitoring in Capstone II.
- **Postman** for API testing during backend development.
- **OpenAPI/Swagger** for API documentation and contract alignment between frontend and backend.
- **Visual Studio Code (VS Code)** as the primary development environment.
- **Figma** for UI/UX design and review.

TODO_CAPSTONE2(FLAG-PM-04): add a short description of the Jira workflow used in Capstone II (board structure, issue types, and how scope changes were tracked).

---

## 5.2 Architecture of the Web Application

### 5.2.1 Physical Architecture

The physical architecture defines how Modula components are deployed and how they communicate at runtime. Modula adopts a web-based client-server architecture with external services for identity verification and media storage.

Capstone II hosting decisions (current):
- Backend hosting: Render
- Database: Supabase (PostgreSQL)
- Object storage: Cloudflare R2

Not yet finalized:
- Frontend hosting provider
- OTP provider for account verification
- CDN strategy for caching object storage assets

TODO_CAPSTONE2(FLAG-OPS-03): confirm frontend hosting provider selection (or decision criteria) for Capstone II.
TODO_CAPSTONE2(FLAG-OPS-04): confirm OTP provider selection for account verification (SMS gateway or equivalent).
TODO_CAPSTONE2(FLAG-OPS-05): confirm CDN approach/provider for caching object storage assets to reduce egress cost.

#### Client Layer

Client devices include smartphones, tablets, and desktop/laptop computers. The client is responsible for:
- rendering the user interface,
- managing local application state,
- supporting offline-first operation through IndexedDB caching and queueing.

#### Frontend Delivery

The frontend is delivered as static web assets built from Flutter. Assets are served via a frontend hosting provider (TBD). The client communicates with backend services over HTTPS APIs.

#### Backend Application Layer

The backend exposes API endpoints for all core capabilities:
- authentication and tenant/membership context,
- access control and policy enforcement,
- sales, orders, cash session, attendance, inventory, discounts,
- offline-first sync (push replay and pull hydration),
- audit logging and background processing (jobs/outbox).

The backend is designed to be largely stateless, with persistent state stored in PostgreSQL.

#### Database Layer

PostgreSQL stores the authoritative operational and transactional data (sales/orders, inventory journal, cash sessions, attendance, policies, audit logs) and supports tenant isolation.

#### External Services

Modula depends on external services for operational capabilities:
- **Object storage (Cloudflare R2)** for media assets (menu/item images).
- **OTP provider (TBD)** for account verification and recovery.
- **Payment provider integrations** for payment confirmation and billing flows (Capstone II design includes KHQR/Bakong-based payment verification for billing, rather than third-party billing providers).

TODO_CAPSTONE2(FLAG-BE-05): provide a short summary of how billing payments are verified/confirmed using the payment gateway approach (academic-level, no sensitive details).

#### Physical Architecture Overview Diagram

TODO_CAPSTONE2(FLAG-FIG-05): insert updated physical architecture diagram for Capstone II, including:
- client + IndexedDB cache/queue,
- frontend hosting (TBD),
- backend on Render,
- database on Supabase Postgres,
- object storage on R2,
- OTP provider (TBD),
- optional CDN in front of object storage.

---

### 5.2.2 Logical Architecture

Modula adopts a modular monolithic logical architecture to balance maintainability, modularity, and operational simplicity. The system is organized into layers with a strict dependency direction.

#### Layered Architectural Model

Modulaâ€™s logical architecture is organized into four primary layers:
- Presentation Layer
- Application (Feature) Layer
- Core Domain Layer
- Infrastructure Layer

#### Presentation Layer

The Presentation Layer is implemented in Flutter and is responsible for user-facing interactions and responsive UI across phone/tablet/desktop. Riverpod is used to manage state in a modular way across feature surfaces.

The UI may hide or disable actions based on roles, policies, or subscription state, but final enforcement is always performed by backend authorization and validation.

#### Application (Feature) Layer

The Application Layer contains feature modules such as:
- Sales and Orders
- Menu
- Inventory
- Cash Session
- Attendance
- Discounts
- Receipts and reporting

Feature modules orchestrate workflows but do not own cross-cutting enforcement. They consume cross-cutting concerns from the Core Domain Layer.

#### Core Domain Layer

Core modules provide system-wide guarantees and shared services, including:
- Authentication and tenant membership
- Access control (authorization)
- Tenant and branch context
- Policy resolution
- Subscription entitlements and capability gating
- Offline sync (push replay + pull hydration)
- Idempotency gate
- Audit logging
- Webhook gateway (normalized ingestion of external events)
- Job scheduler / background jobs (where required)

#### Infrastructure Layer

The Infrastructure Layer provides technical adapters and execution primitives:
- database access,
- object storage integration,
- OTP provider integration,
- background workers for outbox/job processing,
- network communication and API transport.

#### Logical Architecture Diagram

TODO_CAPSTONE2(FLAG-FIG-06): insert updated logical architecture diagram for Capstone II showing:
- Presentation (Flutter + Riverpod),
- Feature modules,
- Core platform modules (offline sync, idempotency, audit, webhook gateway, entitlements),
- Infrastructure adapters (DB/storage/OTP/jobs).

