## 5.2 Architecture of Web Application

### 5.2.1 Physical Architecture

The Modula POS system adopts a distributed, web-based physical architecture designed to support accessibility, scalability, and long-term evolution from an academic capstone project into a production-ready software platform. The physical architecture defines how system components are deployed, where they execute, and how they communicate with one another across different environments.

At the time of Capstone I, the physical architecture of Modula is intentionally defined independently of any specific hosting vendor. This decision allows the system to remain provider-agnostic and supports future migration and scaling strategies described in the project’s long-term infrastructure vision. Specific hosting providers will be evaluated and selected in Capstone II based on operational, reliability, and cost considerations. By deferring vendor lock-in, Modula maintains architectural flexibility while still establishing a clear and complete deployment model.

### Client Layer

The client layer consists of end-user devices through which staff and administrators interact with the system. These devices include smartphones, tablets, and desktop or laptop computers commonly used in café and restaurant environments. In Capstone I, Modula is delivered as a web-based application accessed through modern web browsers, while future phases plan to introduce native mobile applications.

Client devices are responsible for rendering the user interface, handling user interactions, and managing local application state. To support real-world operating conditions—such as unstable or unavailable internet connectivity—the client layer incorporates local data storage using IndexedDB. This enables offline access to essential data such as menus and policies, as well as temporary storage of queued actions that can be synchronized once connectivity is restored. This design directly addresses the operational constraints of small and medium-sized F&B businesses, particularly in regions with inconsistent network reliability.

### Frontend Deployment

The frontend application is deployed as static web assets generated from the Flutter framework. These assets are served through a web server and may be distributed via a content delivery mechanism to improve load performance and availability. The frontend communicates with backend services exclusively through secure HTTPS-based APIs.

From a physical deployment perspective, the public-facing website and the POS application are logically separated, even if they share underlying infrastructure during early deployment stages. This separation reduces operational risk, as traffic spikes or potential denial-of-service events targeting the public website are less likely to impact the POS service used for daily business operations.

### Backend Application Layer

The backend layer executes as a server-side application that exposes a set of RESTful APIs. It encapsulates the core business logic of Modula, including authentication and authorization, sales processing, inventory management, cash session handling, staff attendance tracking, policy enforcement, and reporting.

The backend is designed to be largely stateless, with persistent state stored in the database layer. This approach enables horizontal scaling and simplifies recovery and maintenance. The backend also serves as the central authority for enforcing business rules and access control, ensuring that all operations comply with tenant-specific policies and role-based permissions.

### Database Layer

Persistent data storage is handled by a relational database management system, specifically PostgreSQL. The database stores critical operational data such as sales transactions, inventory records, staff attendance logs, policy configurations, and audit logs. PostgreSQL was selected for its strong ACID guarantees, support for complex relational data models, and suitability for financial and transactional systems.

The database layer enforces data integrity and tenant isolation, ensuring that data belonging to one tenant cannot be accessed or modified by another. Automated backup and recovery mechanisms are part of the intended deployment design, reflecting the system’s role as a business-critical application where data loss would have significant consequences.

Media Storage Service (Images and Assets)
In addition to structured transactional data, Modula manages media assets—primarily images for menu items and stock items. Rather than storing images directly in PostgreSQL, Modula uses an external object storage service for scalability and cost-efficiency.

In the current implementation, Modula integrates with Cloudflare R2 as the object storage layer. Images are uploaded from the client through backend-controlled APIs, and the backend stores only the necessary metadata (such as object keys/paths and public or signed access URLs, depending on the access model). This approach keeps the database lean and avoids using relational storage for large binary files while still ensuring that assets remain consistently associated with the correct tenant and branch context.

This external storage component is part of the physical architecture because it is a separate deployed service that the backend depends on at runtime for asset upload and retrieval.

Identity/OTP Service (Credential Validation Path)
Modula’s authentication design supports secure credential validation and account recovery flows. While Modula currently operates without email-based identity, the intended approach for registration and credential-change verification is OTP (One-Time Password) delivered via SMS (or equivalent provider-supported channel).

From a physical architecture perspective, OTP delivery is treated as an external service dependency (e.g., an SMS gateway provider) accessed only by the backend. The client requests verification; the backend interacts with the OTP provider; and the backend remains the source of truth for validation and security rules (attempt limits, expiry windows, and abuse prevention). This integration is considered part of the architecture even if some OTP enforcement steps are still evolving during Capstone I.

### Local Storage and Offline Support

In addition to server-side persistence, Modula incorporates client-side storage using IndexedDB to support offline-first behavior. When the network is unavailable, the system allows users to continue viewing data and performing permitted actions, which are stored locally and queued for later synchronization. Once connectivity is restored, queued operations are transmitted to the backend in a controlled and idempotent manner.

This hybrid storage model improves system reliability and usability, ensuring uninterrupted operations during temporary network outages and reducing unnecessary data traffic by caching frequently accessed reference data.

Communication and Integration
All communication between system components follows a clear and secure interaction model:
•	Client devices communicate with backend services via HTTPS-based REST APIs.
•	Backend services interact with PostgreSQL through secured database connections.
•	Backend services integrate with external providers (object storage, OTP delivery) using provider APIs and secured credentials.
•	There is no direct communication between client devices and the database or external providers, which helps maintain strong security boundaries and reduces the attack surface.

This layered communication model supports centralized enforcement of policies, consistent validation of business rules, and comprehensive audit logging across all system activities.

### Physical Architecture Overview Diagram

The physical architecture of Modula can be summarized through a layered diagram consisting of client devices at the top, the frontend delivery layer beneath, followed by the backend application layer, and finally the database and supporting services layer at the bottom. Arrows between layers represent API-based communication and data flow. This diagram visually reinforces the separation of concerns and deployment responsibilities described in this section.

### **Architecture Diagram – How to Draw It (for your report)**

Create **Figure 5.x: Physical Architecture of Modula POS** using the following structure:

### **Diagram Components**

1. **Client Device**
    - Label: “Client Device (Web / Future Mobile)”
    - Inside the box:
        - Flutter Web Application
        - IndexedDB (Local Cache & Offline Queue)
2. **Frontend Delivery**
    - Label: “Frontend Hosting (Static Assets)”
    - Inside the box:
        - Flutter Web Build (HTML/JS/CSS assets)
        - Optional CDN (distribution layer)
3. **Backend Server**
    - Label: “Backend Server (TypeScript / Node.js)”
    - Inside the box:
        - REST API
        - Business Logic
        - Policy Enforcement
        - Authentication & Authorization
        - Integration Adapters (Storage, OTP)
4. **Database Server**
    - Label: “PostgreSQL Database”
    - Inside the box:
        - Sales & Orders
        - Inventory & Journals
        - Cash Sessions
        - Attendance
        - Policies
        - Audit Logs
5. **External Services (Side box)**
    - Label: “External Services”
    - Inside the box:
        - Object Storage (Cloudflare R2) — menu/stock images
        - OTP Provider (SMS gateway) — identity verification

### **Connections (Arrows)**

- Client Device → Frontend Hosting
    - Label: “HTTPS (Load App)”
- Client Device → Backend Server
    - Label: “HTTPS / REST API”
- Backend Server → PostgreSQL Database
    - Label: “SQL / Transactions”
- Backend Server ↔ External Services
    - Label: “Provider APIs (Storage / OTP)”
- Client Device ↔ IndexedDB
    - Label: “Local Read/Write (Offline & Cache)”

Optional note near client:

- “Offline operations stored locally and synchronized when online”

### 5.2.2 Logical Architecture

The Modula POS system adopts a modular monolithic logical architecture, designed to balance clarity, maintainability, and scalability while remaining practical for a small development team and an evolving product roadmap. Rather than decomposing the system into distributed microservices, Modula organizes functionality into clearly defined modules within a single deployable application. This approach reduces operational complexity while still enforcing strong separation of concerns and modular boundaries.

The logical architecture defines how responsibilities are structured within the system, how data flows between components, and how business rules are enforced consistently across different features. By explicitly separating core system responsibilities from feature-specific logic and infrastructure concerns, Modula ensures that the system can evolve incrementally without destabilizing existing functionality.

### Layered Architectural Model

Modula’s logical architecture is organized into four primary layers: the Presentation Layer, the Application (Feature) Layer, the Core Domain Layer, and the Infrastructure Layer. Each layer has a distinct responsibility and communicates with adjacent layers through well-defined interfaces.

### Presentation Layer

The Presentation Layer is responsible for all user-facing interactions. In Modula, this layer is implemented using Flutter and consists of screens, widgets, and state management logic that render the user interface for administrators, managers, and cashiers.

State management within the Presentation Layer is handled using Riverpod, which enables reactive, testable, and dependency-aware state handling. Riverpod supports Modula’s modular frontend design by allowing each feature module—such as sales, inventory, or attendance—to manage its own state independently while still consuming shared application context such as authentication status, tenant identity, branch context, and policy configuration.

Importantly, the Presentation Layer does not enforce business rules. Instead, it reacts to capabilities, roles, and policy values provided by the underlying layers. User interface elements may be hidden or disabled based on permissions or policies, but final enforcement occurs outside the UI. This prevents duplication of logic and reduces the risk of inconsistent behavior across different screens or devices.

### Application (Feature) Layer

The Application Layer contains Modula’s feature modules, each responsible for a specific business capability. These include modules such as Sale, Menu, Inventory, Cash Session, Staff Attendance, Discount Management, Reporting, and Receipt handling.

Feature modules orchestrate business workflows and coordinate interactions between the Presentation Layer, Core Domain Layer, and Infrastructure Layer. For example, a sale workflow may involve validating policy values, checking cash session status, applying discounts, deducting inventory, generating audit logs, and updating order status. While multiple modules may be involved in this process, the Sale module remains responsible for the overall transaction flow.

Feature modules do not manage user identity, permissions, or tenant isolation directly. Instead, they consume these concerns from the Core Domain Layer. This separation ensures that cross-cutting rules—such as authorization checks or tenant boundaries—are applied consistently across all features.

### Core Domain Layer

The Core Domain Layer contains Modula’s core modules, which provide system-wide guarantees and shared services. These include Authentication and Authorization, Tenant and Branch Context, Policy and Configuration, Sync and Offline Support, and Audit Logging.

Core modules encapsulate stable domain concepts that should remain consistent even as features evolve. Authentication rules, tenant isolation, and policy evaluation are centralized in the Core Domain Layer rather than duplicated across feature modules. This improves maintainability and reduces the risk of security or data integrity issues.

A key architectural principle in Modula is that feature modules depend on core modules, but core modules do not depend on feature modules. This dependency direction reinforces modular boundaries and allows feature modules to evolve without destabilizing core system behavior.

### Infrastructure Layer

The Infrastructure Layer provides the technical foundations required to execute the system. This includes database access, API communication, offline storage mechanisms, synchronization queues, and idempotency handling.

It also contains the integration adapters for external services that are not part of the domain logic but are required operationally, such as:
•	Object storage adapters (e.g., Cloudflare R2 for images)
•	OTP provider adapters (e.g., SMS gateways) for identity verification workflows

Infrastructure components are deliberately kept free of business logic. Their role is to enable persistence, communication, and execution—not to decide how the system behaves. For example, the Infrastructure Layer uploads an image to object storage, but it does not decide whether the user is authorized to change a menu item; that rule lives in the domain/application layers.

This separation allows Modula to evolve its infrastructure (such as migrating storage providers or changing deployment models) without rewriting feature or core domain logic.

### Inter-Layer Communication

Communication between layers follows a strict and predictable flow. The Presentation Layer interacts with the Application Layer through view models and controllers. The Application Layer consults the Core Domain Layer for authorization, policy evaluation, and tenant/branch context, and relies on the Infrastructure Layer for persistence and external integrations.

Direct interaction between the Presentation Layer and Infrastructure services is explicitly avoided. This prevents tight coupling between UI code and network/storage logic, improving testability and long-term maintainability.

### Modularity and System Evolution

By adopting a modular monolithic logical architecture, Modula achieves a balance between flexibility and simplicity. Modules are independently developed and evolved, yet remain part of a single cohesive system. This supports Modula’s long-term vision of growing from an academic project into a commercial platform, while avoiding premature architectural complexity.

The logical architecture also complements Modula’s policy-driven design. Policies defined in the Core Domain Layer dynamically influence both feature behavior and user interface rendering, enabling the system to adapt to different business configurations without structural changes.

Overall, Modula’s logical architecture provides a clear, maintainable, and extensible foundation that aligns technical design with real-world business requirements and long-term system evolution.

# Text instructions for drawing the Logical Architecture diagram (Modula POS)

Use this to draw a clear **layered logical architecture** diagram (not physical hosting). The audience is academic readers + developers, so keep it structured and readable.

Source text basis: Section 5.2.2 Logical Architecture.  oai_citation:0‡5.2.2.md

---

## 1) Diagram title

**“Modula POS — Logical Architecture (Modular Monolith, Layered)”**

Optional subtitle:
**“Presentation → Application (Feature) → Core Domain → Infrastructure”**

---

## 2) Diagram layout (recommended)

Draw **4 horizontal layers stacked vertically** (top to bottom), inside one big boundary box labeled:

**“Modula POS System (Modular Monolith)”**

Each layer is a wide rectangle containing smaller boxes.

---

## 3) Layer 1: Presentation Layer (Top)

Label the layer: **Presentation Layer (Flutter UI)**

Inside it, draw these boxes :

1. **Flutter Screens & Widgets**
2. **Riverpod State Management**
    
    ---
    
    - annotate: “reactive state, per-feature viewmodels”
3. **Routing / Portals**
    - annotate: “Admin Portal / Manager Portal / Cashier Portal”

Add a small note in this layer:

- “UI can hide/disable actions based on role/policy”
- “Final enforcement happens below UI (not in UI)”

Arrow from this layer down to Layer 2:

- **“User actions / UI events”**
- **“ViewModels call Use Cases”**

## 4) Layer 2: Application Layer (Feature Modules)

Label: **Application (Feature) Layer**

Inside, draw a grouped box called **“Feature Modules (bounded contexts)”** and place modules as smaller boxes inside it:

- **Sales & Orders**
- **Menu**
- **Inventory**
- **Cash Session**
- **Staff Attendance**
- **Discount**
- **Receipt / eReceipt**
- **Reporting**

Annotation inside the feature group:

- “Orchestrates workflows”
- “Coordinates multiple modules in one business operation”
- Example note: “Finalize sale may consult policies + cash session + inventory + audit”

Arrows:

- From Feature Modules down to Core Domain Layer labeled:
    - **“Authorization check”**
    - **“Policy evaluation”**
    - **“Tenant/Branch context”**
- From Feature Modules down to Infrastructure Layer labeled:
    - **“Persistence (DB)”**
    - **“External integrations (storage/OTP)”**
    - **“Sync queue / idempotency”**

---

## 5) Layer 3: Core Domain Layer (Core Modules)

Label: **Core Domain Layer (System-wide guarantees)**

Inside, draw the **Core Modules** as boxes:

1. **Authentication & Authorization**
2. **Tenant & Branch Context**
3. **Policy & Configuration**
4. **Audit Logging**
5. **Sync & Offline Support (core logic / rules)**

Add a dependency direction note (important):

- “Feature modules depend on core modules”
- “Core modules do NOT depend on feature modules”

Optionally draw a small “rule” label near this layer:

- **“Consistent enforcement point”** (e.g., branch freeze, permission checks, policy rules)

---

## 6) Layer 4: Infrastructure Layer (Bottom)

Label: **Infrastructure Layer (Persistence + Adapters)**

Inside, draw boxes for:

### A) Persistence & Data Access

- **PostgreSQL Database Adapter**
    - annotate: “ACID transactions, constraints, reporting queries”
- **Migration Runner**
    - annotate: “SQL migrations, idempotent execution”
- **Repositories / DB Access**

### B) Networking & API Infrastructure

- **HTTP / API Layer**
    - annotate: “Express routes + validation + swagger”

### C) Offline Infrastructure

- **IndexedDB Local Store**
- **Sync Queue / Idempotency**
    - annotate: “staging writes, retry, conflict handling”

### D) External Service Adapters

Put these in a small sub-box labeled **“External Integrations (Adapters)”**:

- **Object Storage Adapter (Cloudflare R2)**
    - annotate: “image upload + retrieval”
- **OTP Provider Adapter (SMS OTP)**
    - annotate: “identity verification flows”

Important note in Infrastructure layer:

- “Infrastructure contains no business decisions”
- “Adapters implement technical IO; rules live above”

---

## 7) Cross-layer communication arrows (make it explicit)

Draw these main arrows:

1. **Presentation → Feature Modules**
    - label: “UI Events / ViewModels invoke Use Cases”
2. **Feature Modules → Core Domain**
    - label: “AuthZ + Tenant/Branch + Policy + Audit”
3. **Feature Modules → Infrastructure**
    - label: “DB writes/reads + external calls”
4. **Infrastructure → Feature Modules**
    - label: “Data results, errors, confirmations”
5. **(Optional) Core Domain → Feature Modules**
    - label: “Capability decisions / policy values returned”

Add a constraint annotation near arrows:

- “Avoid direct Presentation → Infrastructure coupling”
- “Avoid lateral imports between feature modules; coordinate via core contracts/events where possible”

---

## 8) Legend / Notes (small box on the side)

Add a legend box to clarify:

- **Solid arrows** = runtime calls (use case invocation, persistence)
- **Dashed arrows (optional)** = events/outbox (if you want to show event-driven integration)
- **“Core vs Feature”**:
    - Core = system guarantees (auth, policy, audit, context)
    - Feature = business capabilities (sale, inventory, etc.)
- **External services are behind adapters** (R2, OTP), so provider can change without changing domain logic

---

## 9) Final check (what the diagram must communicate)

Before you finalize the drawing, confirm it visually shows:

- A **single system boundary** (modular monolith)
- **Layer separation** (UI does not enforce rules)
- **Core modules are shared and stable**
- **External services appear only as adapters**
- **Offline/Sync appears in both core (rules) and infra (IndexedDB + queue)**