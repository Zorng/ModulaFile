# 5. Detail Concept

## 5.1 Choice of Technology

### **5.1.1 Language and Framework**

The Modula POS system was developed using a modern, cross-platform technology stack designed to support scalability, maintainability, and gradual product evolution from an academic prototype into a production-ready system. The selection of programming languages and frameworks was guided not only by technical capability, but also by practical considerations such as team size, long-term maintainability, and alignment with the project’s vision of providing an affordable and accessible POS solution for small and medium-sized businesses.

For the **frontend**, Modula uses **Flutter**, targeting both web and mobile platforms. Flutter was selected primarily for its ability to support cross-platform development using a single codebase. This decision directly aligns with Modula’s long-term roadmap, in which the system is initially delivered as a web-based POS in Capstone I and later extended into mobile applications in subsequent phases. By adopting Flutter from the beginning, the project avoids the need to reimplement user interfaces and business logic when transitioning from web to mobile environments.

In addition to supporting future mobile development, Flutter addresses practical constraints related to limited development resources. As the project is developed by a small team, maintaining separate implementations for web and mobile platforms would significantly increase development complexity and maintenance overhead. Flutter’s unified framework reduces this burden while ensuring a consistent user experience across different device types, including smartphones, tablets, and desktop terminals commonly used in POS environments.

From an architectural perspective, Flutter supports a **modular monolithic application structure**, which aligns closely with Modula’s system design. Flutter applications are commonly structured using feature-based modules, where each feature encapsulates its own user interface, state management, and interaction logic. This approach improves code organization, readability, and maintainability, especially in applications with multiple functional areas such as sales, inventory, cash sessions, attendance, and reporting.

*Flutter logo here*

The **Dart** programming language further strengthens this architectural approach through strong static typing, explicit imports, and compile-time error detection. These characteristics allow developers to enforce clear boundaries between frontend modules and reduce the likelihood of runtime errors caused by mismatched data models or unintended dependencies. In Modula, this is particularly important because different user roles—such as administrators, managers, and cashiers—interact with different subsets of the system, each with distinct workflows and permissions.

Dart’s language features also support disciplined architectural patterns by encouraging immutability, clear data models, and predictable state transitions. These properties are especially valuable in a POS environment, where incorrect state handling—such as duplicated transactions or inconsistent inventory updates—can lead to operational and financial errors.

*Dart logo here*

To manage application state and dependency boundaries within the Flutter frontend, Modula adopts **Riverpod** as its state management and dependency injection solution. Riverpod complements Flutter’s modular structure by allowing application state to be scoped, isolated, and injected explicitly into feature modules. This enables each module—such as sales, inventory, or cash sessions—to manage its own state independently while still integrating cleanly with shared core services.

The use of Riverpod improves maintainability and testability by reducing tight coupling between user interface components and business logic. It also supports Modula’s modular design philosophy by making dependencies explicit and preventing unintended cross-module interactions. Given the complexity of POS workflows and the need to support offline behavior and role-based access, a predictable and well-structured state management approach was essential.

*Riverpod Logo here*

For the **backend**, Modula is implemented using **TypeScript** running on a Node.js environment. TypeScript was selected over plain JavaScript to introduce static typing and stronger compile-time guarantees. In a POS system where multiple modules exchange structured data—such as sale transactions, inventory updates, policy enforcement, and cash movement records—TypeScript plays a critical role in ensuring consistency and correctness across the system.

*Node.js logo here*

The use of TypeScript also supports Modula’s modular backend architecture by enabling strongly typed interfaces between modules. This is particularly valuable given the project’s development approach, where backend modules expose API contracts that are later consumed by the frontend. Strong typing helps reduce integration errors, improves developer productivity, and allows safer refactoring as business logic evolves. This was especially important in Modula, where early development revealed the risk of data payload mismatches between frontend and backend when specifications were overly granular or ambiguous.

From a long-term perspective, TypeScript enhances maintainability and scalability. As Modula grows beyond the scope of Capstone I, new modules and features are expected to be added incrementally. TypeScript enables developers to detect breaking changes early, making it easier to evolve the system without introducing regressions. This supports Modula’s goal of transitioning from a capstone project into a sustainable software product.

*TypeScript logo here*

Together, Flutter, Dart, Riverpod, and TypeScript form a complementary technology stack that supports Modula’s design philosophy of modularity, clarity, and gradual evolution. Flutter enables a consistent and resource-efficient frontend across platforms, Riverpod enforces clean state boundaries within the frontend architecture, and TypeScript ensures reliability and maintainability in backend development. This combination allows Modula to address both immediate academic requirements and long-term product goals, making the chosen languages and frameworks well-suited for the development of a modern, modular POS system.

### **5.1.2 Databases**

The Modula POS system adopts a hybrid data persistence approach that combines a centralized backend database with client-side storage to support both data integrity and operational resilience. Specifically, Modula uses **PostgreSQL** as the primary backend database and **IndexedDB** as a client-side database within the web application. Each database serves a distinct purpose and together they address the practical and technical requirements of a modern Point of Sale system.

**PostgreSQL** is used as the authoritative backend database and serves as the system of record for all critical business data. This includes sales transactions, orders, inventory records, cash session data, attendance logs, policies, and audit logs. PostgreSQL was selected primarily for its strong support of **ACID (Atomicity, Consistency, Isolation, Durability)** properties, which are essential in POS environments where financial accuracy and data consistency are critical. Operations such as finalizing a sale, deducting inventory, recording cash movements, and updating reports often involve multiple related data changes that must be committed atomically. PostgreSQL ensures that these operations are executed reliably and consistently, even in the presence of system failures.

*Postgres logo here*

In addition, PostgreSQL’s relational data model is well-suited to the structured nature of POS data. Modula manages entities such as tenants, branches, users, menu items, stock items, orders, and policies, many of which have well-defined relationships. PostgreSQL allows these relationships to be enforced through foreign keys and constraints, reducing reliance on application-level validation and helping maintain long-term data integrity as the system evolves. Its advanced querying and aggregation capabilities also support reporting requirements such as sales summaries, inventory status, and cash reconciliation, which are fundamental features of POS systems.

Complementing the backend database, Modula utilizes **IndexedDB** as a client-side database within the web application. IndexedDB is used to support **offline operation**, **local caching**, and **data synchronization**. In real-world POS deployments, network connectivity may be unreliable or intermittent, particularly in small businesses or mobile environments. IndexedDB enables Modula to continue operating under such conditions by storing operational data locally on the client device.

IndexedDB serves two primary roles in Modula. First, it functions as a temporary persistence layer for actions performed while offline, such as creating sales, updating order status, or recording attendance. These actions are stored locally and later synchronized with the backend PostgreSQL database once connectivity is restored. Second, IndexedDB acts as a **local cache** for frequently accessed and relatively stable data, including menu items, categories, modifiers, branch configuration, and policy settings. By caching this data locally, Modula reduces repeated network requests to the backend, lowers data traffic, and improves perceived application performance.

*Indexed DB has no official logo*

The interaction between PostgreSQL and IndexedDB follows a clear responsibility separation. PostgreSQL remains the authoritative source of truth for all persistent data, while IndexedDB is used for transient storage and caching on the client side. Synchronization mechanisms ensure that locally stored data is reconciled with the backend in a controlled and consistent manner. This hybrid database design allows Modula to balance reliability, performance, and data consistency, aligning with modern offline-first web application design principles and the operational realities of POS systems.

Overall, the combined use of PostgreSQL and IndexedDB enables Modula to support transactional accuracy, efficient reporting, offline resilience, and reduced network dependency. This database architecture directly supports the system’s modular design and contributes to its ability to scale from an academic prototype into a practical, real-world POS solution.

### **5.1.3 Tools**

A set of development, collaboration, testing, documentation, and project management tools was employed throughout the Modula project to support structured implementation, coordination among team members, and consistency between system design and actual behavior. These tools were selected to align with the project’s modular architecture and iterative development approach.

**GitHub** was used as the primary version control platform for the project. All frontend and backend source code was managed through GitHub repositories. In addition to code, key project documents—such as module specifications, architectural notes, and design decisions—were maintained alongside the source code. This approach ensured that documentation evolved together with implementation, improved traceability of changes, and reduced the risk of divergence between design intent and system behavior.

**Jira** was utilized for project management and progress monitoring. Development tasks were organized into issues corresponding to system modules, features, and milestones. Jira provided visibility into task ownership, development status, and outstanding work, supporting an iterative development process and enabling the team to manage scope, prioritize tasks, and respond to design refinements during implementation.

**Postman** was used for API testing and validation during backend development. As Modula follows a modular architecture with clearly defined service boundaries, Postman enabled developers to test backend endpoints independently of the frontend. This facilitated early detection of errors, verification of request and response payloads, and smoother integration between backend and frontend components.

**Swagger (OpenAPI)** was employed to document and standardize backend API contracts. By defining endpoints, request parameters, authentication requirements, and response schemas in a machine-readable format, Swagger provided a clear and consistent interface between backend and frontend development. This reduced ambiguity in data exchange, minimized integration errors, and supported modular development by allowing frontend components to be implemented and integrated based on well-defined API contracts.

**Visual Studio Code (VS Code)** served as the primary development environment for both frontend and backend implementation. VS Code was chosen for its lightweight nature, extensive extension ecosystem, and strong support for TypeScript, Dart, and Flutter development. Features such as linting, debugging tools, and integrated version control improved development efficiency and code quality.

**Figma** was used for user interface and user experience design. UI layouts, interaction flows, and role-specific interfaces were designed and reviewed using Figma prior to implementation. This enabled early validation of design decisions, improved communication between designers and developers, and reduced rework during development. Figma played an important role in translating conceptual workflows into implementable interfaces, particularly for complex POS interactions such as sales, cash sessions, and reporting.

Collectively, these tools supported a disciplined and collaborative development process, enabling the team to manage complexity, maintain consistency between design and implementation, and deliver the Modula POS system within the constraints of an academic capstone project.