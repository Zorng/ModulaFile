## 6.3 Configuration

This section describes how Modula is configured to operate reliably across different environments while remaining secure, portable, and maintainable. Configuration in Modula is designed to externalize environment-specific and sensitive parameters rather than embedding them directly into application code. This approach supports clean separation between implementation logic and operational concerns, aligns with modern software engineering best practices, and enables Modula to evolve from a capstone prototype into a scalable production system.

Rather than binding the system to a specific deployment environment or infrastructure provider, Modula adopts a provider-agnostic configuration strategy. Key system behaviors—including database connectivity, API routing, media storage, and runtime settings—are controlled through environment variables and standardized configuration modules.

---

### 6.3.1 Environment Configuration

Modula uses environment-based configuration to manage differences between development, testing, and future production deployments. Environment variables are used to store sensitive information and environment-specific parameters such as database connection strings, API base URLs, runtime flags, and external service credentials.

The project adopts a layered configuration strategy using the following files:

- `.env.example`: A template documenting all required environment variables without exposing sensitive values.
- `.env.local`: Developer-specific configuration used for local development and excluded from version control.
- `.env.development`: Shared configuration for development environments.
- `.env.production`: Reserved for future production deployment in Capstone II.

This structure ensures that sensitive credentials are never committed to source control while enabling consistent setup across team members. On the backend, environment variables are loaded through a centralized configuration module that performs fail-fast validation at startup. If required variables are missing or misconfigured, the application terminates early, preventing undefined runtime behavior.

On the frontend, environment configuration controls API endpoints and environment flags, allowing the same Flutter codebase to connect to different backend environments without code modification. This supports portability and simplifies future deployment to cloud-based hosting providers.

In addition to application configuration, Modula externalizes credentials for infrastructure services. Product images, menu item images, and inventory-related media are stored using cloud-based object storage rather than within the relational database. At the time of Capstone I, Modula integrates with **Cloudflare R2** for object storage. Access credentials, bucket names, and endpoints are provided via environment variables and loaded securely at runtime. This design keeps media storage decoupled from application logic and allows the storage provider to be replaced in the future without major architectural changes.

---

### 6.3.2 API Configuration

API configuration in Modula focuses on consistency, versioning, and safe integration between frontend and backend components. All backend APIs are exposed through versioned routes (e.g., `/v1/auth`, `/v1/menu`, `/v1/sale`), enabling future changes and enhancements without breaking existing clients.

The backend includes integrated API documentation using Swagger, allowing developers to explore endpoints, request schemas, and response formats interactively. During development and testing, Postman is used to validate API behavior independently of the frontend, supporting rapid debugging and verification of business logic.

To reduce integration errors and support parallel development, API contracts are treated as first-class artifacts. Backend modules define explicit request and response schemas, which are shared with the frontend team through documented contracts. This contract-driven approach helps prevent data payload mismatches and improves coordination between frontend and backend development.

API base URLs and version prefixes are configurable through environment variables, allowing seamless switching between local and future hosted environments without requiring changes to application code.

---

### 6.3.3 Database Configuration

Modula uses PostgreSQL as its primary backend database, with all connection details managed through environment variables. Configuration parameters such as host, port, username, password, and database name are externalized to ensure that the application code remains independent of any specific database instance.

Instead of relying on an Object-Relational Mapping (ORM) framework, Modula uses raw SQL for database interaction. This decision provides greater transparency and control over database schema design, queries, and performance characteristics—an important consideration for a transactional POS system. It also supports the academic objective of demonstrating explicit database design and data handling.

Database schema evolution is managed through a custom migration system. SQL migration files are stored in a dedicated `migrations/` directory and executed via a single command during setup. Migrations are written to be idempotent, ensuring safe re-execution without data corruption. This simplifies onboarding for new developers and reduces setup complexity.

At the time of Capstone I, the database runs as a local instance. Containerized deployment using Docker is planned for Capstone II to improve portability, reproducibility, and deployment consistency across environments.

---

### 6.3.4 Dependency and Runtime Configuration

Dependency management and runtime configuration are standardized across the project to ensure reproducible builds and consistent development environments. The backend uses `pnpm` for dependency management, providing efficient installs and strict dependency resolution. The backend runtime is based on Node.js version 20.x, with TypeScript used to enforce static typing and improve maintainability.

The frontend uses the Flutter SDK with a fixed version constraint to ensure consistency across development machines. Flutter’s dependency management system ensures that UI components, state management libraries (such as Riverpod), and networking tools remain aligned across platforms.

Development workflows are standardized through documented scripts and commands, reducing setup friction and minimizing environment-related issues. External infrastructure services, including Cloudflare R2 for media storage, are accessed through environment-based configuration and treated as replaceable components rather than tightly coupled dependencies.

Overall, Modula’s configuration strategy supports the project’s non-functional requirements for security, portability, and maintainability, while remaining flexible enough to accommodate future scaling and infrastructure changes beyond the scope of Capstone I.

## 6.4 Implementation of Feature 
!!! NOT YET FINALIZED, STILL PATCHING!!!
!!!PATCHED!!!

sdfdsfsdfs

## 6.4 Implementation of Feature

### **6.4.1 Authentication and Authorization**

Authentication and authorization form the foundation of the Modula POS system, as all subsequent operations—such as sales processing, inventory management, cash handling, and reporting—depend on a secure and well-defined access control mechanism. The implementation of this module ensures that only authenticated users can access the system and that each user’s actions are constrained by their assigned role and tenant context.

Modula implements a role-based authentication model in which users authenticate using a phone number and password. Upon successful authentication, the system establishes an authenticated session that is associated with a specific account and tenant. This session context is propagated throughout the application and is used to determine both access rights and operational scope, such as which branches and features a user is allowed to interact with.

Authorization in Modula is implemented using **role-based access control (RBAC)**. Each user is assigned one of three primary roles: **Administrator**, **Manager**, or **Cashier**. These roles define the set of actions a user may perform within the system. For example, administrators have full access to system configuration, policies, and reporting; managers have limited administrative capabilities within their assigned branches; and cashiers are restricted primarily to operational tasks such as sales processing, cash sessions, and attendance.

The authentication module integrates closely with the **Tenant and Branch Context** module. After login, the system resolves the user’s active tenant and branch assignments, ensuring that all subsequent operations are executed within the correct organizational scope. This design prevents cross-tenant data access and enforces strict data isolation between different businesses using the platform.

From an implementation perspective, authentication and authorization logic is centralized in the backend and enforced consistently across all feature modules. Frontend components rely on authenticated session state to render appropriate user interfaces, such as administrator or cashier portals, but do not independently enforce business rules. This separation ensures that access control cannot be bypassed through client-side manipulation.

The module also supports multiple tenants per account, allowing a single user to operate multiple independent businesses without requiring multiple login credentials. Each tenant is treated as a fully isolated operational environment, and subscription status is evaluated at the tenant level to determine feature availability.

Overall, the Authentication and Authorization module provides a secure entry point to the Modula system, establishes clear user boundaries, and ensures that all subsequent system interactions are executed in a controlled and auditable manner. This foundation is critical to maintaining data integrity, operational security, and scalability as the system grows beyond the scope of Capstone I.