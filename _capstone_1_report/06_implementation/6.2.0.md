## 6.2 Step of Implementation

### 6.2.1 Project Setup

The implementation of the Modula POS system began with establishing a stable and reproducible project foundation for both frontend and backend development. Given the modular scope of the system and the intention to support parallel development, particular attention was paid to tooling consistency, environment separation, and early architectural alignment.

### Frontend Project Initialization

The frontend application was initialized using Flutter’s standard project scaffolding tool (flutter create), with Flutter version ^3.9.2. Web support was enabled from the beginning of the project to ensure that the system could be delivered as a browser-based POS during Capstone I, while remaining compatible with future mobile deployment. Enabling web support early allowed the frontend architecture, routing, and state management to be designed with cross-platform constraints in mind, avoiding later refactoring when extending the system beyond the web environment.

The Flutter project structure was prepared to support feature-based modular development, aligning with the modular specifications defined during the design phase. This early alignment ensured that UI components, ViewModels, and data access layers could evolve independently within each feature module.

### Backend Project Initialization

The backend was initialized using pnpm init, with Node.js version 20.19 and TypeScript configured from the start of development. TypeScript was adopted immediately to provide static typing, enforce clear module boundaries, and reduce integration errors between backend services and frontend consumers. By avoiding an initial JavaScript-only phase, the project minimized technical debt and ensured that type safety was present throughout the entire implementation process.

The backend project was structured as a modular monolithic application, where each domain module could be developed and tested independently while remaining part of a single deployable service. This approach supported incremental development without introducing the operational complexity of microservices at an early stage.

### Repository Management and Version Control

Frontend and backend codebases were maintained in separate repositories hosted on GitHub. This separation reflected the distinct build processes, dependencies, and deployment considerations of the two applications. A module-based branching strategy was adopted, allowing developers to work on individual modules or features in isolation before merging changes into the main development branch. This approach reduced integration conflicts and supported parallel development across multiple system components.

### Environment Configuration

Environment-specific configuration was managed using environment variable files. The backend project defined .env.local for local development, .env.development for shared team development, .env.production for future deployment, and .env.example as a reference template. This separation ensured that sensitive credentials were not committed to version control while allowing consistent configuration across different environments. Local development environments were explicitly isolated to prevent accidental coupling with shared or production settings.

### Database Setup and Migration Strategy

During Capstone I, the system was developed using a local PostgreSQL instance. Rather than relying on an Object–Relational Mapping (ORM) framework, database schema management was handled using raw SQL migration scripts. A custom migration mechanism was implemented to allow all database migrations to be applied through a single command, simplifying setup for developers and reducing dependency on external tooling.

This approach provided fine-grained control over database schema evolution and ensured transparency of data structures, which is particularly important for POS systems that require strong consistency and traceability. While Docker-based database deployment was not introduced during Capstone I, the project was designed with containerization in mind for future production environments.

### Development Tooling

The project standardized on pnpm as the package manager for backend dependency management, ensuring faster installs and consistent dependency resolution. API development and testing were supported using Postman, while Swagger was used to document API contracts and facilitate communication between backend and frontend teams during integration.

### Initial Architectural Alignment

Before feature implementation began, the team prioritized defining module specifications and system boundaries. Modules were planned first, and implementation details were refined through continuous feedback between frontend and backend development. API versioning using route prefixes such as /v1/auth/ and /v1/menu/ was introduced at the start of development to ensure backward compatibility and allow future evolution of the system without breaking existing clients.

This structured setup phase established a solid foundation for subsequent feature development, enabling Modula to be implemented in a disciplined, modular, and scalable manner throughout Capstone I.

### 6.2.2 Project Structure

This section describes how the Modula POS system is structured at the code level for both frontend and backend implementations. The project structure reflects the design principles established in earlier sections, particularly modularity, separation of concerns, and support for parallel development. Rather than focusing on theoretical architecture, this section explains how those concepts are realized concretely within the source code repositories.

---

### Frontend Project Structure

```
Modula Frontend (Flutter)
├─ lib/
│  ├─ app.dart                  # App bootstrap (theme, providers, router)
│  ├─ main.dart                 # Entry point
│  ├─ core/
│  │  ├─ routing/app_router.dart# GoRouter route table
│  │  ├─ network/dio_client.dart# Shared Dio setup
│  │  ├─ theme/                 # Theme + responsive breakpoints
│  │  └─ widgets/               # Reusable UI (portal shell/actions, search bars, dropdowns, net image helpers)
│  └─ features/                 # Feature modules (feature-first, layered)
│     ├─ auth/                  # Login/session, portals (admin/cashier)
│     ├─ menu/                  # Menu items/categories/modifiers
│     ├─ sale/                  # Cart/order flow, item detail
│     ├─ inventory/             # Stock items, categories, restock, on-hand, journal
│     ├─ cash_session/          # Start/close/takeover cash sessions
│     ├─ policy/                # Policy UI + data
│     ├─ staff/                 # Staff UI (list/detail/form; mock data)
├─ assets/                      # Icons, animations, images
└─ docs/
   ├─ apiContracts/             # Backend contract stubs (TS)
   ├─ apiSchema/                # Backend schema docs
   └─ DEVICE_AGNOSTIC_SESSIONS.md# Cash-session behavior notes

Feature module (example: lib/features/<feature>/)
├─ data/         # API clients + repositories (Dio + server contracts)
├─ domain/
│  └─ models/    # Entities/value objects used across the feature
├─ ui/
│  ├─ viewmodels/# Riverpod state/logic for screens
│  ├─ view/      # Screens/pages for this feature
│  └─ widgets/   # Feature-specific UI components
└─ (tests/ as needed for the feature)

```

**Figure X+1: Modula Frontend Project Structure**

The frontend of Modula is implemented using Flutter and organized using a feature-oriented modular architecture. Rather than structuring the codebase purely by technical layers, the system is decomposed into functional feature modules that correspond directly to POS capabilities such as sales, inventory, cash sessions, and policy configuration. This structure aligns with the system’s modular design principles and supports independent feature development.

Each feature is encapsulated under lib/features/<feature>/ and follows a consistent internal layering pattern. This internal structure separates responsibilities while keeping all logic related to a feature within a single bounded context:
•	The data layer handles API communication and repository abstractions.
•	The domain layer defines feature-specific models and value objects.
•	The UI layer contains screens, widgets, and view models responsible for presentation and interaction.

State management is implemented using Riverpod, with view models encapsulating business interaction logic and exposing reactive state to the UI. Providers are scoped at the feature level, reinforcing modular boundaries and preventing unintended coupling between unrelated features.

At the application level, shared infrastructure such as routing, theming, network configuration, and reusable UI components is centralized under lib/core/. This prevents duplication across features and ensures consistent behavior throughout the application. Navigation is defined declaratively using a centralized router, with role-based access enforced through distinct portals for administrators and cashiers.

To support parallel development, frontend features are initially implemented using mock repositories and placeholder data where backend services are not yet available. Once the corresponding backend module is completed, the mock data layer is replaced with real API integrations. This workflow allows frontend development to proceed independently while remaining aligned with evolving backend contracts.

Overall, this frontend structure balances modularity, maintainability, and development efficiency. It supports Modula’s iterative development approach, where UI design, business logic, and backend integration evolve together through continuous feedback and refinement.

---

---

### Backend Project Structure

```
ModulaBackend (repo)
├─ migrations/                  # Root SQL migrations (replayed in order)
├─ scripts/                     # Dev tooling (setup wizard, helpers)
├─ src/
│  ├─ server.ts                 # Composition root (bootstrap + route mounting)
│  │
│  ├─ platform/                 # Cross-cutting infrastructure (“tech plumbing”)
│  │  ├─ config/                # Env loading + typed config
│  │  ├─ db/                    # Postgres pool, migrations runner, transactions
│  │  ├─ events/                # In-process bus + outbox dispatcher
│  │  ├─ http/                  # Shared middleware, swagger, common routes
│  │  ├─ logger/                # Logging setup
│  │  └─ security/              # Shared auth types/ports (used by modules)
│  │
│  ├─ shared/                   # Shared-kernel utilities + event contracts
│  │  └─ events.ts              # Versioned domain event types
│  │
│  └─ modules/                  # Feature modules (bounded contexts)
│     ├─ auth/
│     ├─ tenant/
│     ├─ menu/
│     ├─ inventory/
│     ├─ sales/
│     ├─ cash/
│     ├─ policy/
│     ├─ reporting/
│     ├─ attendance/
│     └─ accountSettings/
│
└─ package.json / tsconfig.json / jest.config.js

Each feature module (example: src/modules/<module>/)
├─ api/                         # HTTP routes/controllers + validation
├─ app/                         # Use cases/services + ports (interfaces)
├─ domain/                      # Entities + business rules
├─ infra/                       # DB repositories/adapters
└─ tests/                       # Module tests

```

**Figure X: Modula Backend Project Structure**

The backend of Modula is implemented as a **modular monolithic application** using TypeScript and Node.js. Rather than adopting a microservices architecture, the project uses a single deployable service that is internally divided into well-defined modules. This design balances architectural clarity with operational simplicity, which is appropriate for both a capstone project and an early-stage product.
To further clarify how the backend architecture is realized in practice, Figure X presents the actual project directory structure of the Modula backend repository. This textual structure illustrates how the system’s conceptual modular architecture is mapped directly into the source code, reinforcing the separation between feature modules, shared infrastructure, and cross-cutting concerns.

The backend follows a clean, layered structure inspired by Clean Architecture principles:

- **API layer** handles HTTP requests and input validation.
- **Application layer** contains use cases and application services.
- **Domain layer** defines core business entities and rules.
- **Infrastructure layer** implements database access and external integrations.

At the repository level, the backend is organized as follows:

- `src/server.ts` acts as the composition root. It initializes the application, loads configuration, wires module dependencies, registers routes, and starts the HTTP server.
- `src/modules/` contains all feature modules, such as authentication, tenant management, sales, inventory, cash sessions, attendance, policy, and reporting.
- `src/platform/` provides shared infrastructure, including database access, configuration loading, logging, event handling, and security utilities.
- `src/shared/` serves as a shared kernel for common types, errors, and domain event contracts.
- `migrations/` stores raw SQL migration scripts.
- `scripts/` contains developer tooling, such as setup and automation scripts.
- `context/` and `modSpec/` hold architectural documentation and canonical module specifications used during development.

A strict rule is enforced to prevent lateral imports between modules. Modules interact either through defined interfaces (ports) or via domain events. Cross-module communication is handled using an in-process event bus with an outbox pattern, ensuring reliable event dispatch without tight coupling.

Database access is implemented using raw SQL rather than an ORM. Migration scripts are stored as ordered SQL files and executed by a custom migration runner. This approach provides full control over database schema design and avoids abstraction overhead, which is suitable for a POS system requiring precise data handling.

---

### Alignment Between Frontend and Backend Structures

The frontend and backend project structures are intentionally aligned around the same set of functional modules. Features such as sales, inventory, cash sessions, and attendance exist on both sides, sharing a common conceptual boundary defined by the module specifications.

This alignment reduces integration friction and supports the project’s development workflow. Backend teams implement modules according to the agreed specifications and expose API contracts. Frontend teams consume these contracts when integrating features, replacing mock repositories with real data sources. Versioned API routes (e.g., `/v1/auth`, `/v1/menu`) further support controlled evolution of the system.

By structuring both codebases around modular features rather than purely technical layers, Modula achieves a high degree of cohesion and clarity. This structure supports parallel development, simplifies maintenance, and enables the system to evolve incrementally beyond the scope of Capstone I.