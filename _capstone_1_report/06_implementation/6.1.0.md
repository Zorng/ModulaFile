# 6. Implementation

This section describes how the Modula POS system was implemented based on the requirements and architectural decisions presented in Sections 4 and 5. Rather than re-stating requirements or design rationale, it focuses on how the proposed modular architecture was realized in practice through the integration of the frontend, backend services, databases, and supporting components such as configuration, offline synchronization, and policy enforcement. The section begins with a system topology overview, followed by project setup and structure, configuration management, and finally the implementation of core and feature modules delivered in Capstone I.

## 6.1 Project Topology

This section describes the **project topology** of the Modula POS system, focusing on how the system’s components interact at runtime and how data flows between them during normal operation. While Section 5.2.1 (Physical Architecture) explains where the system is deployed and Section 5.2.2 (Logical Architecture) explains how responsibilities are layered, the project topology provides a **runtime interaction view** that connects these perspectives. It illustrates how client applications, backend services, databases, and external services cooperate to support core POS workflows.

### 6.1.1 Runtime Components

At runtime, the Modula POS system consists of the following major components:

- **Client Applications**
    
    The client layer is implemented using Flutter and deployed primarily as a web-based POS interface. It is used by Administrators, Managers, and Cashiers to interact with the system. The client is responsible for rendering the user interface, managing local UI state, and supporting offline operation through local storage.
    
- **Backend API Service**
    
    The backend is implemented as a modular monolithic service using TypeScript. It exposes a set of HTTP APIs grouped by feature modules such as authentication, sales, inventory, cash sessions, and reporting. The backend is responsible for enforcing business rules, applying policies, performing authorization checks, and coordinating data persistence.
    
- **Primary Database (PostgreSQL)**
    
    PostgreSQL serves as the centralized backend database and acts as the authoritative source of truth for all persistent business data. This includes sales records, inventory data, cash sessions, attendance logs, policies, and audit trails.
    
- **Client-side Storage (IndexedDB)**
    
    IndexedDB is used within the client application to support offline operation, local caching, and deferred synchronization. It does not serve as an authoritative data source and is only used to temporarily store operational data until it can be synchronized with the backend.
    
- **External Services**
    
    Modula integrates with external services to support specific system capabilities:
    
    - An **OTP/SMS service** is used during authentication and credential-related workflows.
    - An **external object storage service** is used for storing media assets such as menu images, inventory item images, and tenant or branch logos.

### 6.1.2 Interaction Principles

Several principles govern how these components interact:

- Client applications do not directly access the database or external services.
- All business operations and data persistence are mediated by the backend API.
- The backend service is authoritative and enforces consistency, policy rules, and access control.
- Client-side storage supports resilience and performance but never replaces backend validation.
- External services are accessed only by the backend to preserve security and centralized control.

These principles ensure a clear separation of responsibilities and reduce the risk of inconsistent or unauthorized data manipulation.

### 6.1.3 Meaning of Arrows in the Topology Diagram

In the project topology diagram, arrows represent **runtime data exchange** rather than code-level dependencies.

- Arrows from the client to the backend represent synchronous request–response interactions, such as submitting credentials, creating sales, or retrieving menu data.
- Arrows from the backend to the database represent read and write operations on persistent data.
- Dashed arrows between the client and backend represent deferred or asynchronous interactions, such as offline synchronization.
- Arrows between the backend and external services represent service integrations initiated by the backend.

The arrows therefore describe how information flows through the system during execution.

### 6.1.4 Client–Backend Interaction

The client applications communicate with the backend through a secured API boundary. Typical interactions include authenticating users, retrieving configuration and policy data, creating and finalizing sales, updating order states, and initiating cash session actions. All requests are validated and authorized by the backend before any business logic is executed or data is persisted.

### 6.1.5 Backend–Database Interaction

The backend interacts bidirectionally with the PostgreSQL database. Read operations retrieve the current system state, such as inventory levels or reporting data, while write operations persist authoritative records, including finalized sales, inventory movements, and audit logs. Transactional guarantees provided by the database ensure consistency across multi-step operations.

### 6.1.6 Offline Operation and Synchronization

When network connectivity is unavailable, the client records user actions locally using IndexedDB. These actions may include draft sales, attendance check-ins, or order status updates. Once connectivity is restored, the client submits queued actions to the backend. The backend validates each action against current system state and policies before committing it to the database or rejecting it with a clear error.

### 6.1.7 Integration with External Services

The backend integrates with an OTP/SMS service to support authentication workflows. Requests to send or verify one-time passwords are initiated by the backend, and the responses are used to determine authentication outcomes. Similarly, interactions with external object storage are mediated by the backend, which manages upload processes and stores metadata in the primary database. Clients do not hold permanent credentials for these services.

### 6.1.8 Summary

The project topology of Modula emphasizes centralized authority, controlled interaction boundaries, and resilience to unreliable network conditions. By clearly defining how client applications, backend services, persistent storage, and external integrations interact at runtime, the topology supports both the functional requirements of a POS system and the long-term goals of scalability, maintainability, and secure operation.